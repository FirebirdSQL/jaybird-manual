[#ref-max-field-size]
=== Maximum field size (`maxFieldSize`)

[.until]_Jaybird 7_

In Jaybird 6 and older, the `maxFieldSize` property of `Statement` is effectively ignored -- the value is only stored, and otherwise ignored.

[.since]_Jaybird 7_

In Jaybird 7 and higher, the `maxFieldSize` property of `Statement` is used to truncate values returned from a result set.

The `maxFieldSize` value is defined in bytes, and is applied when the value is greater than zero.
Truncation occurs for `CHAR`, `VARCHAR`, `BINARY`, `VARBINARY`, `BLOB SUB_TYPE TEXT` (JDBC `LONGVARCHAR`), and `BLOB SUB_TYPE BINARY` and other Firebird built-in (positive) blob subtypes (JDBC `LONGVARBINARY`), but not custom (negative) subtypes (Jaybird considers those JDBC `BLOB`, and JDBC specifies that type should not be limited by `maxFieldSize`).

In case of `CHAR`, `VARCHAR`, `BINARY`, and `VARBINARY`, the truncation is performed when fetching a row (in the GDS-ng layer) _if_ it is not an `RDB$DB_KEY` column.
This is a client-side truncation, and does not reduce the number of bytes transferred, only the number of bytes retained in memory and returned from the result set.

In the case of built-in (non-negative)  blob subtypes, the truncation is performed in the result set field implementation in the JDBC layer.
This is a client-side truncation, but it may reduce the number of bytes transferred _if_ the blob wasn't already transferred as an inline blob.

For these blob subtypes, the truncation will not occur for methods returning a `Blob`, `Clob`, `InputStream` or `Reader` _if_ the result set is not cached locally (cached result sets are used for holdable result sets and emulated scrollable result sets).
In the case of `InputStream` and `Reader`, this doesn't conform to the JDBC requirements, but avoided complications in the implementation.
We may address this in the future.

Caveats:

* Given the truncation happens at a set number of bytes, values in a multibyte character set (UTF8) might end in the Unicode replacement character (U+FFFD, '`&#xFFFD;`') due to truncation before the end of the encoded codepoint.
* Jaybird will accept any non-negative value for `maxFieldSize`.
The JDBC apidoc recommends using values greater than `256`.
* A too small `maxFieldSize` may result in "`wrong`" values or missing precision being returned without error for numeric and Boolean getters;
for datetime getters it may result in missing precision without errors, or parse errors.
* Setting the max field size after execute may not be immediately applied to the current result set for `CHAR`, `VARCHAR`, `BINARY`, and `VARBINARY`:
** For a locally cached result set: never, as the rows were truncated to the `maxFieldSize` on execute.
** Otherwise, already fetched rows are truncated to the `maxFieldSize` on their fetch, and only rows returned by a subsequent fetch will apply the new limit.
* For `LONGVARCHAR`/`LONGVARBINARY`, the value will be truncated on access, with the following caveats:
** For cached blobs, the limit is applied on retrieval, and applies to all methods (as the cached value is truncated).
** The value of a cached blob (holdable result set or emulated scrollable result set) will be truncated to the initial `maxFieldSize`.
Subsequent use of a larger `maxFieldSize` will continue to return the shorter value.
* The detection of `RDB$DB_KEY` columns includes "`normal`" `BINARY`/`CHAR CHARACTER SET OCTETS` columns called `DB_KEY`.

For further details, see https://github.com/FirebirdSQL/jaybird/blob/master/devdoc/jdp/jdp-2025-07-statement-max-field-size.adoc[jdp-2025-07: Statement Max Field Size].
