[[ref-datetime]]
=== Date/time types

// TODO Expand

[[ref-datetime-tz]]
==== Time zones

[.since]_Firebird 4_

Firebird 4 introduced time zone types, with types `TIME WITH TIME ZONE` and `TIMESTAMP WITH TIME ZONE`.
See the Firebird 4 release notes and `doc/sql.extensions/README.time_zone.md` in the Firebird installation for details on these types.

[.since]_Jaybird 3.0.6_ +
Since Jaybird 3.0.6, two connection properties, `timeZoneBind` and `sessionTimeZone`, are available to provide limited support for these types.
See <<ref-datetime-timezonebind>> and <<ref-datetime-sessiontimezone>> for details.

[.since]_Jaybird 4_ +
Since Jaybird 4, the time zone types are supported under Java 8 and higher, using the Java 8 (or higher) version of Jaybird.
Time zone types are not supported under Java 7, and you will need to enable legacy time zone bind to use these types.
With legacy time zone bind, Firebird will convert to the equivalent `TIME` and `TIMESTAMP` (`WITHOUT TIME ZONE`) types using the session time zone.
Time zone bind can be configured with connection property `timeZoneBind`, for more information see <<ref-datetime-timezonebind>>.

[[ref-datetime-tz-scope]]
===== Scope of time zone support

[.since]_Jaybird 4_

JDBC 4.2 introduced support for time zones, and maps these types to `java.time.OffsetTime` and `java.time.OffsetDateTime`.
JDBC does not define explicit setters for these types.
Use `setObject(index, value)`, `updateObject(index, value)`, `getObject(index/name)` or `getObject(index/name, classType)`.

Firebird 4 supports both offset and named time zones.
Given the definition in JDBC, Jaybird only supports offset time zones.
On retrieval of a value with a named zone, Jaybird will make a best effort to convert to the equivalent offset using Java's time zone information.
If no mapping is available the time will be returned at UTC (offset zero).

Jaybird 4 supports the following Java types on fields of time zone types (those marked with * are not defined in JDBC)

`TIME WITH TIME ZONE`:

* `java.time.OffsetTime` (default for `getObject`)
** On get, if the value is a named zone, it will derive the offset using the current date
* `java.time.OffsetDateTime`
** On get the current date is added
** On set the date information is removed
* `java.lang.String`
** On get applies `OffsetTime.toString()` (eg `13:25:13.1+01:00`)
** On set tries the default parse format of either `OffsetTime` or `OffsetDateTime` (eg `13:25:13.1+01:00` or `2019-03-10T13:25:13+01:00`) and then sets as that type
* `java.sql.Time` (*)
** On get obtains `java.time.OffsetDateTime`, converts this to epoch milliseconds and uses `new java.sql.Time(millis)`
** On set applies `toLocalTime()`, combines this with `LocalDate.now()` and then derives the offset time for the default JVM time zone 
* `java.sql.Timestamp` (*)
** On get obtains `java.time.OffsetDateTime`, converts this to epoch milliseconds and uses `new java.sql.Timestamp(millis)`
** On set applies `toLocalDateTime()` and derives the offset time for the default JVM time zone
  
`TIMESTAMP WITH TIME ZONE`:

* `java.time.OffsetDateTime` (default for `getObject`)
* `java.time.OffsetTime` (*)
** On get, the date information is removed
** On set, the current date is added
* `java.lang.String`
** On get applies `OffsetDateTime.toString()` (eg `2019-03-10T13:25:13.1+01:00`)
** On set tries the default parse format of either `OffsetTime` or `OffsetDateTime` (eg `13:25:13.1+01:00` or `2019-03-10T13:25:13+01:00`) and then sets as that type
* `java.sql.Time` (*)
** On get obtains `java.time.OffsetDateTime`, converts this to epoch milliseconds and uses `new java.sql.Time(millis)`
** On set applies `toLocalTime()`, combines this with `LocalDate.now()` and then derives the offset date time for the default JVM time zone
* `java.sql.Timestamp` (*)
** On get obtains `java.time.OffsetDateTime`, converts this to epoch milliseconds and uses `new java.sql.Timestamp(millis)`
** On set applies `toLocalDateTime()` and derives the offset date time for the default JVM time zone
* `java.sql.Date` (*)
** On get obtains `java.time.OffsetDateTime`, converts this to epoch milliseconds and uses `new java.sql.Date(millis)`
** On set applies `toLocalDate()` at start of day and derives the offset date  time for the default JVM time zone

[[ref-datetime-tz-scope-legacy]]
====== Support for legacy JDBC date/time types

For the `WITH TIME ZONE` types, JDBC does not define support for the legacy JDBC types (`java.sql.Time`, `java.sql.Timestamp` and `java.sql.Date`).
To ease the transition and potential compatibility with tools and libraries, Jaybird does provide support.
However, we strongly recommend to avoid using these types. 

Compared to the `WITHOUT TIME ZONE` types, there may be small discrepancies in values as Jaybird uses 1970-01-01 for `WITHOUT TIME ZONE`, while for `WITH TIME ZONE` it uses the current date.
If this is problematic, then either apply the necessary conversions yourself, enable legacy time zone bind, or define or cast your columns to `TIME` or `TIMESTAMP`.

[[ref-datetime-tz-scope-javatime]]
====== No support for other java.time types
  
The types `java.time.LocalTime`, `java.time.LocalDateTime` and `java.time.LocalDate` are not supported for the time zone types.
Supporting these types would be ambiguous.
If you need to use these, then either apply the necessary conversions yourself, enable legacy time zone bind, or define or cast your columns as `TIME` or `TIMESTAMP`. 

Jaybird also does not support non-standard extensions like `java.time.Instant`, or `java.time.ZonedDateTime`.
If there is interest, we may add them in the future.

[[ref-datetime-timezonebind]]
===== Time zone bind configuration

[.since]_Jaybird 3.0.6_

The connection property `timeZoneBind` (alias `time_zone_bind`) is a connection property to configure the time zone bind (see also `SET TIME ZONE BIND` in the Firebird 4 release notes).

This property needs to be explicitly set if you are using Jaybird 4 on Java 7 or Jaybird 3 (on any Java version), and need to handle the `WITH TIME ZONE` types.
It can also be used for tools or applications that expect `java.sql.Time`/`Timestamp` types and cannot use the `java.time.OffsetTime`/`OffsetDateTime` types returned for the `WITH TIME ZONE` types.

Possible values (case insensitive):

* `legacy`
+    
Firebird will convert a `WITH TIME ZONE` type to the equivalent `WITHOUT TIME ZONE` type using the session time zone to derive the value.
+    
Result set columns and parameters on prepared statements will behave as the equivalent `WITHOUT TIME ZONE` types.
This conversion is not applied to the database metadata which will always report `WITH TIME ZONE` information.
* `native`
+
Behaves as default (`WITH TIME ZONE` types supported), but value will be explicitly set.

Any other value will result in error `isc_time_zone_bind` (code 335545255, message _"Invalid time zone bind mode &lt;value&gt;"_) on connect.

NOTE: This feature requires Firebird 4 beta 2 or higher (or a snapshot build version 4.0.0.1481 or later). 
It will be ignored in earlier builds as the necessary database parameter buffer item does not exist in earlier versions.

[[ref-datetime-sessiontimezone]]
===== Connection property sessionTimeZone

The connection property `sessionTimeZone` (alias `session_time_zone`) does two things: 

1.  specifies the Firebird 4 session time zone ([.since]_Jaybird 3.0.6_),
2.  specifies the time zone to use when converting values of without time zone types to the legacy JDBC datetime types on all Firebird versions ([.since]_Jaybird 4_).  

See <<ref-datetime-sessiontimezone-fb>> for information on the effects of `sessionTimeZone` on the server-side.

Valid values are time zone names known by Firebird, we recommend to use the long names (eg `Europe/Amsterdam`) and not the ambiguous short IDs (eg `CET`).
Although not required, we recommend to use time zone names that are known by Firebird and Java (see <<ref-datetime-sessiontimezone-convert>> for caveats).

In Jaybird 3, `sessionTimeZone` will only configure the server-side session time zone.
Client-side, Jaybird will continue to use the JVM default time zone for parsing the without time zone values to the `java.sql.Time/Timestamp/Date` types.
Setting `sessionTimeZone` to the JVM default time zone will yield the best (ie correct) values, but not setting it (and thus using the server default) will retain behaviour that is backwards compatible with behaviour of previous versions of Jaybird.
In Jaybird 4, this property also configures client-side parsing of values to these legacy types.

[NOTE]
====
On Jaybird 3, we recommend not setting this property, or setting it to the default JVM time zone.
If you set it to a different time zone, then we recommend that you do not use the legacy `java.sql.Time/Timestamp/Date` types, but instead use `java.time.LocalTime/LocalDateTime/LocalDate`.
====

The remainder of this section only applies to Jaybird 4 and higher.

By default, Jaybird 4 and higher will use the JVM default time zone as reported by `java.util.TimeZone.getDefault().getID()` as the session time zone.
Using the JVM default time zone as the default is the best option in the light of JDBC requirements with regard to `java.sql.Time` and `java.sql.Timestamp` using the JVM default time zone.

To use the default server time zone and the Jaybird 3 and earlier behaviour to use the JVM default time zone, set the connection property to `server`.
This will result in the conversion behaviour of Jaybird 3 and earlier.
Be aware that this is inconsistent if Firebird and Java are in different time zones.

[[ref-datetime-sessiontimezone-fb]]
====== Firebird 4 session time zone

The session time zone is used for conversion between `WITH TIME ZONE` values and `WITHOUT TIME ZONE` values (ie using cast or with legacy time zone bind), and for the value of `LOCALTIME`, `LOCALTIMESTAMP`, `CURRENT_TIME` and `CURRENT_TIMESTAMP`, and other uses of the session time zone as documented in the Firebird 4 documentation.

The value of `sessionTimeZone` must be supported by Firebird 4.
It is possible that time zone identifiers used by Java are not supported by Firebird.
If Firebird does not know the session time zone, error (`Invalid time zone region: <zone name>`) is reported on connect. 

In Jaybird 4 and higher, Jaybird will apply the JVM default time zone as the default session time zone.
The use of the JVM default time zone as the default session time zone will result in subtly different behaviour compared to previous versions of Jaybird and - even with Jaybird 4 - Firebird 3 or earlier, as current time values like `LOCALTIMESTAMP` (etc) will now reflect the time in the JVM time zone, and not the server time zone rebased on the JVM default time zone. 

As an example, with a Firebird in Europe/London and a Java application in Europe/Amsterdam with Firebird time 12:00, in Jaybird 3, the Java application will report this time as 12:00, in Jaybird 4 with Firebird 4, this will now report 13:00, as that is the time in Amsterdam if it is 12:00 in London (ignoring potential DST start/end differences).

Other examples include values generated in triggers and default value clauses.

[[ref-datetime-sessiontimezone-convert]]
====== Session time zone for conversion

[.since]_Jaybird 4_

For `WITHOUT TIME ZONE` types, the session time zone will be used to derive the `java.sql.Time`, `java.sql.Timestamp` and `java.sql.Date` values.
This is also done for Firebird 3 and earlier.

If Java does not know the session time zone, no error is reported, but when retrieving `java.sql.Time`, `java.sql.Timestamp` or `java.sql.Date` a warning is logged and conversion will happen in GMT, which might yield unexpected values.

We strongly suggest that you use `java.time.LocalTime`, `java.time.LocalDateTime` and `java.time.LocalDate` types instead of these legacy datetime types.

For `WITH TIME ZONE` types, the session time zone has no effect on the conversion to the legacy JDBC date/time types: the offset date/time is converted to epoch milliseconds and used to construct these legacy types directly.

Executing `SET TIME ZONE <zone name>` statements after connect will change the session time zone on the server, but Jaybird will continue to use the session time zone set in the connection property for these conversions. 

[[ref-datetime-tz-convert]]
===== Time zone support for CONVERT

Although not defined in JDBC (or ODBC), Jaybird has added a non-standard extension to the `CONVERT` JDBC escape to allow conversion to the time zone types. 

In addition to the standard-defined types, it also supports the type names `TIME_WITH_TIME_ZONE`, `TIME_WITH_TIMEZONE`, `TIMESTAMP_WITH_TIME_ZONE` and `TIMESTAMP_WITH_TIMEZONE` (and the same with the `SQL_` prefix). 

[[ref-datetime-tz-caveats]]
===== Caveats for time zone types

* Time zone fields do not support `java.time.LocalDate`, `java.time.LocalTime`, `java.time.LocalDateTime`.
* Firebird 4 redefines `CURRENT_TIME` and `CURRENT_TIMESTAMP` to return a `WITH TIME ZONE` type.
Use `LOCALTIME` and `LOCALTIMESTAMP` (introduced in Firebird 3.0.4) if you want to ensure a `WITHOUT TIME ZONE` type is used.
* The database metadata will always return JDBC 4.2 compatible information on time zone types, even on Java 7, and even when legacy time zone bind is set.
For Java 7 compatibility the JDBC 4.2 `java.sql.Types` constants `TIME_WITH_TIMEZONE` and `TIMESTAMP_WITH_TIMEZONE` are also defined in `org.firebirdsql.jdbc.JaybirdTypeCodes`.
* ([.since]_Jaybird 4) The default `sessionTimeZone` is set to the JVM default time zone, this may result in different application behavior for `DATE`, `TIME` and `TIMESTAMP`, including values generated in triggers and default value clauses.
To prevent this, either switch those types to a `WITH TIME ZONE` type, or set the `sessionTimeZone` to `server` or to the actual time zone of the Firebird server.
