[[transactions]]
== Using transactions

Transactions are used to group SQL statements into a single block that
satisfies so called ACID properties: atomicity, consistency, isolation
and durability. In other words, all statements executed within
transaction will either succeed and their results will be permanently
stored in the database or the effect of the statement execution will be
undone.

=== JDBC transactions

Firebird supports multiple concurrent transactions over the same
database connection. This allows applications that work via the native
Firebird API to save the number of network connections, which in turn
saves the resources on the serverfootnote:[Additionally, before the
InterBase was open-sourced, this allowed application developers to
create multi-threaded application without need to purchase additional
user licenses.].

This model however cannot be applied to each database engine in the
world and the designers of the JDBC API have chosen a model where each
database connection has one and only one active transaction associated
with it. Also, unlike the Firebird model, where transactions require
explicit start, JDBC specification requires the driver to start
transaction automatically as soon as a transactional context is needed.

The following code shows a very simple example of using transactions in
JDBC where a hypothetical intruder that increases salary of each
employee twice and uses explicit transaction control in JDBC. It also
tries to hide his own identity and if the operations succeed, he commits
the transaction, otherwise he rolls the changes back.

[source,java]
.Example of explicit transaction control
----
Connection connection = ...

connection.setAutoCommit(false); // <1>

Statement stmt = connection.createStament();
try {
    stmt.executeUpdate("UPDATE employee " + 
        " SET salary = salary * 2"); // <2>
        
    // ... do some more changes to database
    // to hide the identity of the person
    // that messed up the salary information
    // by deleting the audit trails logs, etc.
    
    stmt.executeUpdate("DELETE FROM audit_trails");
    
    connection.commit(); // <3>
} catch(SQLException ex) {
    connection.rollback(); // <4>
}
----

In order to use transactions, the application first switches the auto-commit mode off
(see below for more information), then creates a `java.sql.Statement`
object, executes an UPDATE statement. Please note, that there is no
explicit transaction start, new transaction will be started right before
executing the statement (step 2).

If we have database where not only referential integrity is preserved,
but also reasonable security rules are encoded in the triggers, it will
raise an error preventing cleaning the audit trails information. In this
case the intruder chooses to undo all the changes he made, so that nobody
notices anything. But if no security rules are implemented, he commits
the transaction.

When connection uses explicit transaction control, each transaction must
be finished by calling the `commit()` or `rollback()` methods of the
`Connection` object before the connection is closed. If a transaction
was not finished, but the `close` method is called, the active
transaction is rolled back automatically. This also happens when the
transaction was not finished, the connection was not closed explicitly
and that `Connection` object became eligible for garbage collection. In
this case, the `close()` method is implicitly invoked by the class
finalizer, which in turn rolls the transaction back.

=== Auto-commit mode

Each newly created connection by default has the auto-commit property
set on. In other words, the duration of the transaction is limited by
the duration of statement execution, or speaking formal language –
the transaction is ended when the statement is completed. The point when
statement execution is considered complete, is defined in the
specification as:

.Rules when the statement is completed in auto-commit mode
* For insert, update, delete and DDL statements, the statement is
complete as soon as it has finished executing.
* For select statements, statement is complete when the associated
result set is closed. The result set is closed as soon as one of the
following occurs:
** all of the rows have been retrieved
** the associated Statement object is re-executed
** another Statement object is executed on the same connection
* For CallableStatement objects, the statement is complete, when all of
the associated result sets have been closed.

If there is an ongoing transaction and the value of the auto-commit
property is changed, the current transaction is committed.

Note, when a connection is obtained via `javax.sql.DataSource` object
and container managed transactions are used (for example, the
application is executing inside an EJB container), it is an error to
call `setAutoCommit` method.

Special care should be taken when using multiple statements in
auto-commit mode. The JDBC 2.0 specification did not fully define the rules
for the statement completion as it did not define the behavior
of multiple `ResultSet` objects created using the same connection object
in auto-commit mode.

Since Firebird does not allow the result set to remain open after the
transaction ends, Jaybird 1.5.x and below cached the complete result set
in memory when the SELECT statements were executed and corresponding
transaction was committed. It had an adverse effect on allocated memory
when the result set is big, especially when it contains BLOB fields. The
JDBC 3.0 specification addressed this unclear situation (see above) and
Jaybird 2.1 was improved to correctly handle them. It also allowed to
improve the memory footprint – the driver no longer caches
non-scrollable and non-holdable result sets in memory.

However, some Java applications that do not conform the current JDBC
specification might no longer work with Jaybird 2.1 and above unless
additional steps are taken.

The piece of code below works perfectly with explicit transaction
control. However, it won't work correctly with a driver that complies
with JDBC 3.0 specification, while the `selectStmt` and `updateStmt`
object were created by the same connection object (step 1). When the
UPDATE is executed in step 3, the result set produced by the SELECT
statement must be closed before the execution. When Java application
tries to fetch the next record by calling the `rs.next()` method, it
will receive an `SQLException` with a message "Result set object is
closed".

The only correct solution to this situation is to fix the application by
either using explicit transaction control, or by using two connection
objects, one for SELECT statement and one for UPDATE statement.

[source,java]
.Non-compliant usage of nested statements in auto-commit mode
----
Statement selectStmt = connection.createStatement(); // <1>
Statement updateStmt = connection.createStatement();

ResultSet rs = selectStmt.executeQuery(
  "SELECT * FROM myTable");
  
while(rs.next()) { // <2>
  int id = rs.getInt(1);
  String name = rs.getString(2);
  
  updateStmt.executeUpdate("UPDATE anotherTable SET " +
      " name = '" + name + "' WHERE id = " + id); // <3>
}
----

Unfortunately, not all applications can be changed either because there
is no source code available or, simply, because any change in the code
requires complete release testing of the software. To address this, Jaybird 2.1
introduced the connection parameter `defaultHoldable` which makes result
sets holdable by default. The holdable result sets will be fully cached
in memory, but won't be closed automatically when transaction
endsfootnote:[Other cases, e.g. closing the statement object or the
connection object will still ensure that the result set object is
closed. If you need result sets that can be "detached" from the
statement object that created them, please check the `javax.sql.RowSet`
implementations.]. Please note, this property affects also the cases
with explicit transaction control.

=== Read-only Transactions

A transaction can be declared read-only to reduce the possibility of
lock conflicts. In general, this makes little sense for Firebird,
because of its multi-generational architecture, where readers do not
block writers and vice versa. However, in some cases it can be useful.

It is not allowed to connect with a read-write transaction to a database
located on a read-only media, for example, a CD-ROM. The reason is that,
in order to guarantee consistency of the read-write transactions,
Firebird has to increase the transaction identifier when transaction
ends, and to store the new value on the so-called Transaction Inventory
Page even if no changes were made in that transaction. This requirement
can be relaxed if transaction is declared read-only and the engine
ensures that no data can be modified.

Another reason is that long running read-write transactions inhibit the
process of collecting garbage, i.e. a process of identifying previous
versions of the database records that are no longer needed and releasing
the occupied space for the new versions. Without garbage collection the
database size will grow very fast and the speed of the database
operations will decrease, because the database engine will have to check
all available record versions to determine the appropriate one.

Therefore, if you are sure that application won't modify the database in
the transaction, use the `setReadOnly` method of the
`java.sql.Connection` object to tell the server that the transaction is
read-only.

=== Transaction Isolation Levels

// TODO Rephrase, weird as introduction

To address the performance issue, the isolation property is relaxed. The
ANSI/ISO SQL standard defines four such levels, each next one weaker
than the previous. These isolation levels were reflected in the JDBC
specification:

[cols="2,3",options="header",]
.JDBC transaction isolation levels and their characteristics
|=======================================================================
|JDBC isolation level |Description
|TRANSACTION_SERIALIZABLE |Transactions with this isolation level
prohibit the phantom reads, the situation when one transaction reads all
rows satisfying the WHERE condition, another transaction inserts a row
satisfying that condition, and first transaction re-executes the
statement.

|TRANSACTION_REPEATABLE_READ |This isolation level prevents the
non-repeatable reads, a situation when a row is read in one transaction,
then modified in another transaction, and later re-read in the first
transaction. In this case different values had been read within the same
transaction.

|TRANSACTION_READ_COMMITTED |Transactions with this isolation level can
see only committed records. However, it does not prevent so-called
non-repeatable reads and phantom reads.

|TRANSACTION_READ_UNCOMMITTED |The weakest isolation level, or better to
say level with no isolation. Such transactions can see the not yet
committed changes to the data in the database from the concurrently
running transactions.
|=======================================================================

Firebird, however, defines other isolation levels: `read_committed`,
`concurrency` and `consistency`. Only the `read_committed` isolation
level can be mapped to the same level defined by the ANSI/ISO SQL
standard. The dirty reads are prevented, non-repeatable reads as well as
phantom reads can occur.

The `concurrency` isolation level is stronger than repeatable read
isolation defined in ANSI/SQL standard and satisfies the requirements of
a serializable isolation level, however, unlike RDBMSes with locking
concurrency control, it guarantees better performance.

And finally Firebird provides a `consistency` isolation level which in
combination with table reservation feature guarantees the deadlock-free
execution of transactions. A transaction will be prevented from starting
if there is already another one with the overlapping sets of the
reserved tables. This isolation level guarantees truly serial history of
transaction execution.

In order to satisfy the JDBC specification Jaybird provides a following
default mapping of the JDBC transaction isolation levels into Firebird
isolation levels:

* TRANSACTION_READ_COMMITTED is mapped to `read_committed` isolation
level in Firebird – any changes made inside a transaction are not
visible outside a transaction until the transaction is committed. A
transaction in read-committed mode sees all committed changes made by
other transactions even if that happened after start of the current
transaction.
* TRANSACTION_REPEATABLE_READ is mapped to `concurrency` isolation level
in Firebird – any changes made inside this transaction are not visible
outside a transaction until the transaction is committed. A transaction
in repeatable-read sees only those changes that were committed before
the transaction started. Any committed change in another transaction
that happened after the start of this transaction is not visible in this
transaction.
* TRANSACTION_SERIALIZABLE is mapped into `consistency` isolation level
in Firebird – any modification to a table happens in serial way: all
transactions wait until the current modification is done. This mode can
be considered as a traditional pessimistic locking scheme, but the lock
is placed on the whole table. See Chapter "<<Table Reservation>>" for more information.

The mapping is specified in the `isc_tpb_mapping.properties` file that
can be found in the Jaybird archive and can be overridden via the
connection properties

* via the `tpbMapping` property that specifies the path to the
`PropertiesResourceBundle` with the new mapping of the isolation level;
* via the direct specification of the JDBC transaction isolation level.
The following code contains an example of such operation, the values in
the mapping are described in section "<<Transaction Parameter Buffer>>".
* via the connection pool configuration.

[source,java]
.Overriding the default isolation level mapping
----
Properties props = new Properties();
props.setProperty("user", "SYSDBA");
props.setProperty("password", "masterkey");
props.setProperty("TRANSACTION_READ_COMMITTED",
    "isc_tpb_read_committed,isc_no_rec_version," +
    "isc_tpb_write,isc_tpb_nowait");
    
Connection connection = DriverManager.getConnection(
    "jdbc:firebirdsql://localhost:3050/c:/example.fdb",
    props);
----

The overridden mapping is used for all transactions started within the
database connection. If the default mapping is overridden via the
connection pool configuration, it will be used for all connections
created by the pool.

=== Savepoints

Savepoints provide finer-grained control over transactions by providing
intermediate steps within a larger transaction. Once a savepoint has
been set, transaction can be rollback to that point without affecting
preceding work.

In order to set a savepoint, use following code:

[source,java]
.Example of using savepoints
----
Statement stmt = connection.createStatement();

stmt.executeUpdate(
    "INSERT INTO myTable(id, name) VALUES (1, 'John')");
    
Savepoint savePoint1 = 
    connection.setSavepoint("savepoint_1");
    
stmt.executeUpdate(
    "UPDATE myTable SET name = 'Ann' WHERE id = 1");
... 

connection.rollback(savePoint1);

// at this point changes done by second update are undone
----

Note, rolling back to the savepoint automatically releases and
invalidates any savepoints that were created after the released
savepoint.

If the savepoint is no longer needed, you can use the
`Connection.releaseSavepoint` method to release system resources. After
releasing a savepoint it is no longer possible to rollback the current
transaction to that savepoint. Attempts to call the `rollback(Savepoint)` method
will result in an `SQLException`. Savepoints that have been created
within a transaction are automatically released when transaction is
committed or rolled back.

=== Transaction Parameter Buffer

The behavior of Firebird transactions is internally controlled by
the Transaction Parameter Buffer (TPB), which specifies different
transaction properties:

* the transaction isolation level;
* the transaction's read-only or read-write mode;
* the lock conflict resolution mode – wait or no wait;
* and, finally, the table reservations – their names and reservation
modes.

The TPB is automatically generated depending on the transaction
isolation level specified for the `java.sql.Connection` object and
usually there is no need to manipulate the TPB directly. Additionally,
if the connection is set to read-only mode, this is reflected in the TPB
by appropriate constant. However, the lock resolution mode as well as
table reservations cannot be specified by using the standard JDBC
interfaces. For the cases where this is needed, Jaybird provides an
extension of the JDBC standard.

[source,java]
.Example of specifying custom TPB
----
FirebirdConnection fbConnection =
    (FirebirdConnection)connection;
    
TransactionParameterBuffer tpb = 
    fbConnection.createTransactionParameterBuffer();
    
tpb.addArgument(TransactionParameterBuffer.READ_COMMITTED);
tpb.addArgument(TransactionParameterBuffer.REC_VERSION);
tpb.addArgument(TransactionParameterBuffer.WRITE);
tpb.addArgument(TransactionParameterBuffer.WAIT);

fbConnection.setTransactionParameters(tpb);
----

The above presents an example of populating the TPB with custom
parameters.

==== Isolation level

Firebird supports three isolation
levels: `read_committed`, `concurrency` and `consistency` which are
represented by appropriate constants in the
`TransactionParameterBuffer` class. The isolation level specifies the
way the database engine processes the record versions on read
operations. The `concurrency` isolation level is also often called
SNAPSHOT and the `consistency` - SNAPSHOT TABLE STABILITY isolation
levels.

In `consistency` and `concurrency` modes Firebird database engine loads
the different versions of the same record from disk and checks the
"timestamps" of each version and compares it with the "timestamp" of the
current transaction. The record version with the highest timestamp that
is however lower or equal to the timestamp of the current transaction is
returned to the application. This effectively returns the version of the
record that was when the current transaction started and guarantees that
neither non-repeatable reads nor phantom reads can ever occur.

In `read_committed` mode Firebird database engine, however, accesses the
record version with the highest timestamp, for which the corresponding
transaction is marked as committed. This prevents engine from reading
the record versions which were modified in concurrent transactions
that are not yet committed or were rolled back for whatever reasons.
However, such mode allows non-repeatable reads as well as phantom reads
if the concurrent transaction that modified records or inserted new ones
had been committed.

The `read_committed` isolation mode requires another constant that
specifies the behavior of the transaction when it meets a record version
with the timestamp which belongs to the currently running transaction
which is not yet committed.

Most applications require the `TransactionParameterBuffer.REC_VERSION` mode, which is shown in the
code above. In this mode database engine fetches the latest committed
version as described before.

The `TransactionParameterBuffer.NO_REC_VERSION` constant tells database
engine to report the lock conflict when an uncommitted record version is
seen while fetching data from the database. The outcome of the operation
is then controlled by the lock resolution mode (see section
<<Lock resolution mode>>).

==== Read-only transactions

The read-only or read-write transaction mode is controlled by two
constants:

* `TranscationParameterBuffer.READ` and
* `TransactionParameterBuffer.WRITE`

When the read-write mode is specified, database engine stores the
"timestamp" of new transaction in the database even no modification will
be made in the transaction. The "timestamp" affects the garbage
collection process, since the database engine cannot release records
that were modified in the transactions with higher "timestamps" even
when these record versions are no longer needed (in other words, when
there are already newer versions of the records). Thus, long-running
read-write transaction inhibits the garbage collection even when no
modifications are done in it.

Therefore, it is recommended to set the read-only mode for the
transaction when it is used for read operations.

==== Lock resolution mode

The RDBMS systems that use pessimistic locking for the concurrency
control lock the records regardless of the operation type, read or
write. When application tries to read a record from the database,
database engine tries to obtain a "read lock" to that record. If the
operation succeeds and application later tries to update the record, the
lock is upgraded to the "write lock". And finally, if the resource is
already locked for write, concurrent transactions cannot lock it for
reading, since the system cannot allow the transaction to make a
decision based on data that might be rolled back later. This approach
significantly decreases concurrency. However, the databases systems that
employ the record versioning mechanism do not have such restriction
because each transaction "sees" its own version of the record – the only
possible conflict happens when two concurrent transactions try to obtain
"write lock" for the same database record.

Firebird belongs to the latter, and on `read_committed` and
`concurrency` isolation levels it behaves appropriately – there are no
lock conflicts between readers and writers, and only writers competing
for the same resource raise a lock conflict. However, on the
`consistency` isolation level Firebird emulates the behavior of the
systems with pessimistic locking – read operation will conflict with
write. Even more, the locks are obtained for the whole tables (see
"<<Table Reservation>>" chapter for details).

The following table summarizes the above for Firebird 2.0. It shows that
read-committed or repeatable read transactions conflict only when they
simultaneously update the same rows. In contrast, a `consistency`
transaction conflicts with any transaction running in read-write mode,
e.g. as soon as a `consistency` transaction gets write access to a
table, other read-write transactions are not allowed to make changes in
that tables.

[cols="34%,18%,18%,15%,15%",]
.Lock conflicts within one table depending on the isolation level
|=======================================================================
| |Read-commited, Concurrency read-write |Read-commited, Concurrency
read-only |Consistency, read-write |Consistency, read-only

|Read-committed, Concurrency read-write |some updates may conflict |
|conflict |conflict

|Read-committed, Concurrency read-only | | | |

|Consistency read-write |conflict | |conflict |conflict

|Consistency read-only |conflict | |conflict |
|=======================================================================

=== Table Reservation

Table reservation allows to specify the database tables and the
corresponding access modes at the beginning of the transaction. When
transaction is started, engine tries to obtain the requested locks for
the specified tables and proceeds only when all of them were
successfully obtained. Such behavior allows to create a deadlock-free
execution historiesfootnote:[This approach follows the two-phase locking
protocol, where all locks are acquired on the beginning of the
transaction and are released only when transaction is finished.].

The table reservation is specified via TPB and includes the table to
lock, the lock mode (read or write) and lock type (shared, protected and
exclusive).

[source,java]
.Example of using table reservation facility in Firebird
----
Connection connection = ...
TransactionParameterBuffer tpb =
  connection.createTransactionParameterBuffer(); // <1>

tpb.addArgument(TransactionParameterBuffer.CONSISTENCY); // <2>
tpb.addArgument(TransactionParameterBuffer.WRITE);
tpb.addArgument(TransactionParameterBuffer.NOWAIT);

tpb.addArgument(TransactionParameterBuffer.LOCK_WRITE,
  "TEST_LOCK");
tpb.addArgument(TransactionParameterBuffer.PROTECTED);

connection.setTransactionParameters(tpb); // <3>

// next transaction will lock TEST_LOCK table for writing
// in protected mode
----

This shows an example of reserving the TEST_LOCK table for writing in a
protected mode. The code does the following:

<1> Create a new instance of `TransactionParameterBuffer` class.
<2> Populate the TPB. The first three statements were
described in the section "<<Transaction Parameter Buffer>>". The fourth call specifies that the application wants
to obtain a lock on the table `TEST_LOCK` for writing. The fifth call
specifies the type of the lock to obtain, in our case the protected
lock.

<3> Set the new TPB to be used for the next transaction.

The lock mode to the table specified in the TPB can be either

* `TransactionParameterBuffer.LOCK_READ` for read-only access to the
table;
* or `TransactionParameterBuffer.LOCK_WRITE` for read-write access to
the table.

The lock type can be either

* `TransactionParameterBuffer.SHARED` for shared access to the table;
* or, `TransactionParameterBuffer.PROTECTED` for protected access to the
table;

The `TransactionParameterBuffer.EXCLUSIVE` mode was introduced in latter
versions of Firebird, however it behaves like `PROTECTED` mode for all
read-write transactions.

The lock conflict table depends on the isolation level of the
transactions and has the following properties:

* `LOCK_WRITE` mode always conflicts with another `LOCK_WRITE` mode
regardless of the lock type and transaction isolation mode;
* `LOCK_WRITE` always conflicts with another `LOCK_READ` mode if both
transactions have `consistency` isolation, but has no conflict with
shared-read locks it if another transaction has either `concurrency` or
`read_committed` isolation level;
* `LOCK_READ` mode never conflicts with `LOCK_READ` mode.

