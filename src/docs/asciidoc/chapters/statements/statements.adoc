[[statements]]
== Executing statements

After obtaining a connection, the next thing to do is to execute an SQL statement.
The JDBC specification distinguishes three kinds of statements:

1. Regular statements to execute fixed SQL requests, 
2. prepared statements to execute SQL code with parameters, 
3. and callable statements to execute stored procedures.

=== The java.sql.Statement interface

The `java.sql.Statement` interface is the simplest interface to execute SQL statements.
It distinguishes three types:

* statements that return results, or, in other words, queries;
* statements that change the state of the database but return no results;
* `INSERT` statements (or other statements with similar behaviour) that return the values of the columns which were generated by the database engine while inserting the record.

Let's check one of the typical usages shown below.
In general the usage pattern of the statement consists of three steps.

[source,java]
.Typical way to execute query to get information about the user
----
try (Statement stmt = connection.createStatement(); // <1>
     ResultSet rs = stmt.executeQuery(
         "SELECT firstName, lastName FROM users" +
         " WHERE userId = 5") // <2>
){
  if (rs.next()) {
    String firstName = rs.getString(1);
    String lastName = rs.getString(2);
  }
} // <3>
----

<1> Create a `Statement` object by calling the `createStatement()` method of the `Connection` object.

<2> Use the Statement object by calling its methods, in our case we execute a simple query `SELECT firstName, lastName FROM users WHERE userId = 5`.
Processing of the query result will be discussed in details in <<resultsets>>.

<3> Close the result set and statement to release all allocated resources.
In our example this is done using the try-with-resources block.
With try-with-resources, Java takes care of closing resources in the right order, even if exceptions occur, or if a resource was not allocated (say, if `executeQuery` throws an exception).

As the connection object is the factory for the statement objects, this puts a constraint on the object lifetime: statements are bound to the connection;
when the connection is closed, all statements that were created by that connection become invalid and the resources allocated by them are released.
However, despite that these resources are released when the connection closes, it is strongly recommended to use the try-with-resources block, to guarantee that resources are released as soon as possible because of reasons that will be discussed later.

A statement can be executed using the following methods:

* `Statement.executeQuery(String)` -- executes a SELECT statement and returns a result set.
If the specified statement does not produce a result set, an `SQLException` is thrown after statement execution.
* `Statement.executeUpdate(String)` -- executes INSERT, UPDATE, DELETE or DDLfootnote:[
DDL -- Data Definition Language.
This term is used to group all statements that are used to manipulate database schema, i.e. creation of tables, indices, views, etc.]
statements and returns the number of updated rows.
If the specified statement is a query, an `SQLException` is thrown.
* `Statement.execute(String)` -- executes a statement and returns `true` when the statement returned a result set, otherwise an update was executed and `false` is returned.
You can use `Statement.getResultSet()` method to get the result of the executed query, or you can use `Statement.getUpdateCount()` when you have executed update statement.

These `execute` methods have several variants for additional features covered in the reference section <<ref-generatedkeys>>.

A statement is closed by calling the `Statement.close()` method, or by using a try-with-resources which calls `close()` behind the scenes.
After a close, the statement object is invalid and cannot be used anymore.

It is allowed to use the same statement object to execute different types of queries one after another.
The code below contains a short example which first performs a select to find the ID of the user 'Joe Doe', and if the record is found, it enables his account.

[WARNING]
====
The concatenation of values into a query string as done in this example is not a good practice as it can leave your code vulnerable to SQL injection.

In this specific case it is safe to do as the values are integers.
In general: don't do this, use a prepared statement instead.
====

[source,java]
.Using the same statement object multiple times to enable user account
----

try (Statement stmt = connection.createStatement();
     ResultSet rs = stmt.executeQuery(
         "SELECT userId FROM users " + 
         "WHERE lastName = 'Doe' AND firstName = 'Joe'")) {
  if (rs.next()) {
    int userId = rs.getInt(1);
        
    int rowsUpdated = stmt.executeUpdate(
        "UPDATE accounts SET accountEnabled = 1 " +
        "WHERE userId = " + userId);
            
    if (rowsUpdated == 0)
      rowsUpdated = stmt.executeUpdate(
          "INSERT INTO accounts (userId, enabled) " +
          "VALUES (" + userId + ", 1)");
                
    if (rowsUpdated != 1) 
      throw new SomeException(
          "User was not updated correctly.");
  }
}
----

The way the code is constructed is quite tricky because of the result set lifetime constraints that are defined by the JDBC specification, please read the chapter <<resultsets>> for more details.

However, here it is done intentionally to emphasize that a single object is used to execute `SELECT` and `UPDATE`/`INSERT` statements.
It also shows how to check whether the executed statement modified expected number of rows -- the application first tries to update the account and only if no rows were updated, it inserts new record into the `accounts` table.

[TIP]
======
This example of 'try update, then insert' approach can be better handled using https://www.firebirdsql.org/file/documentation/html/en/refdocs/fblangref40/firebird-40-language-reference.html#fblangref40-dml-merge[`MERGE`^] or https://www.firebirdsql.org/file/documentation/html/en/refdocs/fblangref40/firebird-40-language-reference.html#fblangref40-dml-update-or-insert[`UPDATE OR INSERT`^].
======

When an application needs to execute DDL statements, it is recommended to use the `Statement.execute(String)` method, as in this case the amount of modified records makes little sense.
The next example shows the creation of database tables using this method.

[source,java]
.Example of creating database tables
----
try (Statement stmt = connection.createStatement()) {
  stmt.execute("CREATE TABLE customer(" + 
      "customerId INTEGER NOT NULL PRIMARY KEY, " + 
      "firstName VARCHAR(20) NOT NULL, " + 
      "lastName VARCHAR(40) NOT NULL)");
}
----

As mentioned earlier, the `Statement.execute(String)` method can also be used to execute statements of an unknown type.

[source,java]
----
try (Statement stmt = connection.createStatement()) {
  boolean hasResultSet = stmt.execute(sql);
  if (hasResultSet) {
    ResultSet rs = stmt.getResultSet();
    ...
  } else {
    int updateCount = stmt.getUpdateCount();
    ...
  }
}
----

It is worth mentioning that according to the JDBC specification `getResultSet()` and `getUpdateCount()` methods can be only called once per result, and in case of using Firebird, that means once per executed statement, since Firebird does not support multiple results from a single statement.
Calling the methods the second time will cause an exception.

// TODO May need some revision to address retrieval of update counts after the result set

=== Statement behind the scenes

The previous examples requires us to discuss the statement object dynamics, its life cycle and how it affects other subsystems in details.

==== Statement dynamics

When a Java application executes a statement, a lot more operations happen behind the scenes:

1. A new statement object is allocated on the server.
Firebird returns a 32-bit identifier of the allocated object, a statement handle, that must be used in next operations.
2.  An SQL statement is compiled into an executable form and is associated with the specified statement handle.
3.  Jaybird asks the server to describe the statement and Firebird returns information about the statement type and possible statement input parameters (we will discuss this with prepared statements) and output parameters, namely the result set columns.
4.  If no parameters are required for the statement, Jaybird tells Firebird to execute statement passing the statement handle into corresponding method.

After this Jaybird has to make a decision depending on the operation that was called.

* If `Statement.execute()` was used, Jaybird only checks the statement type to decide whether it should return `true`, telling the
application that there is a result set for this operation, or `false`, if the statement does not return any result set.
* If `Statement.executeUpdate()` was called, Jaybird asks Firebird to give the information about the number of affected rows.
This method can be called only if the statement type tells that no result set can be returned by the statement.
+
When called for queries, an exception is thrown despite the fact that the statement was successfully executed on the server.
* If `Statement.executeQuery()` was called and the statement type indicates that a result set can be returned, Jaybird constructs a `ResultSet` object and returns it to the application.
No additional checks, like whether the result set contains rows, are performed, as it is the responsibility of the `ResultSet` object.
+
If this method is used for statements that do not return result set, an exception is thrown despite the fact that the statement was successfully executed on the server.

[WARNING]
=====
The described behaviour may change in the future by throwing the exception *before* executing the statement.
=====

When an application does not need to know how many rows were modified, it should use the `execute()` method instead of `executeUpdate()`.
This saves an additional call to the server to get the number of modified rows which can increase the performance in the situations where network latency is comparable with the statement execution times.

The `execute()` method is also the only method that can be used when the application does not know what kind of statement is being executed (for example, an application that allows the user to enter SQL statements to execute).

After using the statement object, an application should close it.
Two different possibilities exist: to close the result set object associated with the statement handle and to close the statement completely.

If, for example, we want to execute another query, it is not necessary to completely release the allocated statement.
Jaybird is required only to compile a new statement before using it, in other words we can skip step 1 (allocating a new statement handle).
This saves us one round-trip to the server over the network, which might improve the application performance.

If we close the statement completely, the allocated statement handle is no longer usable.
Jaybird could allocate a new statement handle, however the JDBC specification does not allow use of a `Statement` object after `close()` method has been called.

==== Statement lifetime and DDL

Step 2 (compiling the SQL statement) in the previous section is probably the most important, and usually, most expensive part of the statement execution life cycle.

When Firebird server receives the "prepare statement" call, it parses the SQL statement and converts it into the executable form: BLR.
BLR, or Binary Language Representation, contains low-level commands to traverse the database tables, conditions that are used to filter records, defines the order in which records are accessed, indices that are used to improve the performance, etc.

When a statement is prepared, it holds the references to all database object definitions that are used during that statement execution.
This mechanism preserves the database schema consistency, it saves the statement objects from "surprises" like accessing a database table that has been removed by another application.

However, holding a reference on the database objects has one very unpleasant effect: it is not possible to upgrade the database schema, if there are active connections to the database with open statements referencing the objects being upgraded.
In other words, if two application are running and one is trying to modify the table, view, procedure or trigger definition while another one is accessing those objects, the first application will receive an error 335544453 "`object is in use`".

To avoid this problem, it is strongly recommended to close the statement as soon as it is no longer needed.
This invalidates the BLR and release all references to the database objects, making them available for the modification.

Special care should be taken when statement pooling is used.
In that case, statements are not released even if the `close()` method is called.
The only possibility to close the pooled statements is to close the pooled connections.
Please check the documentation of your connection pool for more information.

=== The java.sql.PreparedStatement interface

As we have seen, Jaybird already performs internal optimization when it comes to multiple statement execution -- it can reuse the allocated statement handle in subsequent calls.
However, this improvement is very small and sometimes can even be negligible compared to the time needed to compile the SQL statement into the BLR form.

The `PreparedStatement` interface addresses such inefficiencies.
An object that implements this interface represents a precompiled statement that can be executed multiple times.
If we use the execution flow described in the "<<Statement dynamics>>" section, it allows us to go directly to step 4 for repeated executions.

However, executing the same statement with the same values makes little sense, unless we want to fill the table with the same data, which usually is not the case.
Therefore, JDBC provides support for parametrized statements -- SQL statements where literals are replaced with question marks (`?`), so-called positional parameters.
The application then assigns values to the parameters before executing the statement.

Our first example in this chapter can be rewritten as shown below.
At first glance the code becomes more complicated without any visible advantage.

[source,java]
.Example for user account update rewritten using prepared statements
----
try (PreparedStatement stmt1 = connection.prepareStatement(
         "SELECT userId FROM users WHERE " + 
         "lastName = ? AND firstName = ?")) {
  stmt1.setString(1, "Doe");
  stmt1.setString(2, "Joe");
  try (ResultSet rs = stmt1.executeQuery()) {
    
    if (rs.next()) {
      int userId = rs.getInt(1);

      try (PreparedStatement stmt2 =
               connection.prepareStatement(
                   "UPDATE accounts SET accountEnabled = 1 " +
                   "WHERE userId = ?" )) {
        stmt2.setInt(1, userId);

        int rowsUpdated = stmt2.executeUpdate();

        if (rowsUpdated == 0) {
          try (PreparedStatement stmt3 =
                   connection.prepareStatement(
                       "INSERT INTO accounts " +
                       "(userId, enabled) VALUES (?, 1)")) {
            stmt3.setInt(1, userId);
            rowsUpdated = stmt3.executeUpdate();
          }
        }
        if (rowsUpdated != 1)
          throw new SomeException(
              "User was not updated correctly.");
      }
    }
  }
}
----

* First, instead of using just one statement object we have to use three, one per statement.
* Second, before executing the statement we have to set parameters first.
As is shown in the example, parameters are referenced by their position.
The `PreparedStatement` interface provides setter methods for all primitive types in Java as well as for some widely used SQL data types (BLOBs, CLOBs, etc).
The `NULL` value is set by calling the `PreparedStatement.setNull(int)` method.
* Third, we are now forced to use four nested try-with-resources blocks, which makes code less readable.

So, where's the advantage?
First of all, prepared statements parameters protect against SQL injection as the values are sent separately from the statement itself.
It is not possible to change the meaning of a statement due to incorrect string concatenation, so data leaks or other problems caused by SQL injection can be avoided.
Second of all, the driver handles conversion of Java object types to the correct format for the target datatype in Firebird: you don't need to convert a Java value to the correct string literal format for Firebird's SQL dialect.

To address some identified problems, we can redesign our application to prepare those statements before calling that code (for example in a constructor) and close them when the application ends.
In that case the code can be more compact (see the next example). 
Unfortunately, the application is now responsible for prepared statement management.
When a connection is closed, the prepared statement object will be invalidated, but the application will not be notified.
And when the application uses similar statements in different parts of the application, the refactoring might affect many classes, possibly destabilizing the code. 
So, the refactoring on this example is not something we want to do.

[source,java]
.Rewritten example to let application manage prepared statements
----
// prepared statement management
PreparedStatement queryStmt = 
    connection.prepareStatement(queryStr);
PreparedStatement updateStmt = 
    connection.prepareStatement(updateStr);
PreparedStatement insertStmt = 
    connection.prepareStatement(insertStr);
    
......................

// query management
queryStmt.clearParameters();
queryStmt.setString(1, "Doe");
queryStmt.setString(2, "Joe");
try (ResultSet rs = queryStmt.executeQuery()) {
  if (rs.next()) {
    int userId = rs.getInt(1);
        
    updateStmt.clearParameters();
    updateStmt.setInt(1, userId);
    int rowsUpdated = updateStmt.executeUpdate();
        
    if (rowsUpdated == 0) {
      insertStmt.clearParameters();
      insertStmt.setInt(1, userId);
      rowsUpdated = insertStmt.executeUpdate();
    }
            
    if (rowsUpdated != 1) 
      throw new SomeException(
          "User was not updated correctly.");
  }
}
......................

// prepared statement cleanup
insertStmt.close();
updateStmt.close();
queryStmt.close();
----

The answer to the advantage question is hidden in the `prepareStatement(String)` call.
Since the same statement can be used for different parameter values, the connection object could have a possibility to perform prepared statement caching.
A JDBC driver can ignore the request to close the prepared statement, save it internally and reuse it each time application asks to prepare an SQL statement that is known to the connection.

NOTE: Jaybird currently does not perform statement caching

////
=== Prepared statement pooling

*TODO* Feature not supported by Jaybird 3, remove entirely?

As was mentioned before, connection pooling was introduced to reduce
the time needed to obtain a connection. Despite its rich features, the
operation of obtaining new connection in Firebird is cheap – usually
connection pooling in an application that heavily opens and closes
connection brings ~5% of performance.

However there is one more way to speed the application. Execution of
statements in Firebird always happens in three steps:

* Compile the SQL statement into an internal BLR representation, save it
in an internal structure and assign a statement handle to a compiled
statement.
* Execute the statement. First application checks whether the compiled
statement has any parameters and sets them if needed. After that
statement is executed using special call.
* Obtain results of the statement execution, for example number of
updated rows or a result set.

The obvious approach is to save the compiled statement and use it later.
JDBC specification already contains a `java.sql.PreparedStatement`
interface exactly for such purposes. An application prepares statement and
uses it multiple times. This approach works fine within the context of
the same connection.

However, when connection pooling is used, an application can no longer
cache prepared statements, since they are bound to the connection it
obtained from the pool. The application must close all prepared statements
before giving the connection back to pool, but even if it does not do this,
the connection pool will perform this automatically according to the JDBC
specification. All advantages of the prepared statements are undone –
when the application obtains next connection from the pool, it must
re-prepare statements.

The solution to the problem is to use a connection pool that does statement pooling
internally.

[WARNING]
*INFORMATION BELOW IS LARGELY OUTDATED*

The solution to the problem is to allow connection pool do statement pooling
internally. In this case all code remains compliant with the JDBC
specification saving all advantages of prepared statements.

Jaybird 2.1 connection pool has `maxStatements` property that controls
the behavior of the prepared statement pooling:

* If property is set to 0, no statement pooling is performed.
* If property is set to value `n>0`, connection pool will save maximum
_n_ `java.sql.PreparedStatement` objects for the same SQL statement per
connection. Number of pooled `PreparedStatement` objects corresponding
to different SQL statements is not limited.

If application needs more prepared statements simultaneously (i.e. it
prepares new statement before releasing the one being currently in use),
connection pool transparently passes call to the connection object
without pooling those statements. In other words, the request to prepare
statement is always satisfied immediately, but only _n_ prepared
statements will remain pooled, rest will be deallocated when
*`PreparedStatement.close()` method is called.

Following limitations apply:

* Firebird can have approx. 20.000 active statement handles per
connection. Additional care should be used when specifying the value of
`maxStatements` property.
* Neither `java.sql.Statement` nor `java.sql.CallableStatement` objects
are pooled.
* A compiled statement in Firebird contains references on database
objects (tables, views, procedures, etc.) needed to execute that SQL
command. When a connection pool is used, those references are not released
preventing any structure modification of the database objects used in
the SQL statement. Therefore, if structure modification is needed,
connection pool with enabled statement pooling must be shut down.

==== Prepared statement pooling – advantages and drawbacks

Originally statement pooling was introduced to preserve the
`PreparedStatement` advantages when connection pooling is used. Since
the lifetime of the statement object is bound to the connection object,
prepared statement must be closed before the connection is released to
the connection pool.

When `FBConnectionPoolDataSource` or `FBWrappingDataSource` classes are
used to obtain database connections, prepared statement pooling is there
for granted. No application modification is needed to enable it, but the
performance improvement, depending on the application, might reach up to
50%.

Connections that were obtained via `DriverManager` do not provide
statement pooling and application must handle prepared statements
itself.

The biggest drawback of the statement pooling is the fact that statement
handle is not released even when application does not need the
statement, which in turn prevents database administrator to upgrade the
database schema. To overcome this issue two additional methods were
added to the connection pooling classes as well as the possibility to
switch the statement pooling off.

The `restart()` method defined in the `FBConnectionPoolDataSource` and
in the `FBWrappingDataSource` classes. This method closes all open
connection residing in the pool. Connections that are currently used in
the application are marked as "pending for close" and are deallocated as
soon as application returns them to the pool. This algorithm guarantees
that eventually all connections will be closed and statements will be
deallocated without closing the working applications. The only
requirement for successful database schema upgrade is that the
application does not "lock" the database objects before the upgrade
happens. Unfortunately there is no easy application design guidelines
that would guarantee the hot schema upgrade.

The `restart()` method can also be used during database schema upgrade
when the Firebird ClassicServer is used. There is an old issue related
to the architecture of the ClassicServer – each instance of the database
engine that is serving the application connection caches the metadata
information. So, even if the application did not have any open statement
and the database schema upgrade was successful, open connections will
not notice the change. The `restart()` method softly closes all open
connections that are not in use and ensures that new connections
obtained from the pool will use new ClassicServer instances with fresh
metadata information.

The `shutdown()` method defined in the pool classes that marks the pool
as invalid and closes all open connection regardless whether they are
currently in use or not. This method can be used if a short-time
application down time is acceptable. To continue functioning application
must construct a new pool and replace the old one since `shutdown()`
method invalidates the pool object.
////

[[callable-statement]]
=== The java.sql.CallableStatement interface

The `CallableStatement` interface extends `PreparedStatement` with methods for executing and retrieving results from stored procedures.
It was introduced in the JDBC specification in order to unify access to the stored procedures across the database system.
The main difference to `PreparedStatement` is that the procedure call is specified using the portable escaped syntax:footnote:[escape syntax in limited form also works for `Statement` and `PreparedStatement`]

.Unified escaped syntax for stored procedure execution
....
procedure call ::= {[?=]call <procedure-name>(<params>)}
params ::= <param> [, <param> ...]
....

Each stored procedure is allowed to take zero or more input parameters, similar to the `PreparedStatement` interface.
After being executed, a procedure can either return data in the output parameters or it can return a result set that can be traversed.
Though the interface is generic enough to support database engines that can return both and have multiple result sets.
These features are of no interest to Jaybird users, since Firebird does not support them.

The IN and OUT parameters are specified in one statement.
The syntax above does not allow to specify the type of the parameter, therefore additional facilities are needed to tell the driver which parameter is will contain output values, the rest are considered to be IN parameters.

==== Firebird stored procedures

Firebird stored procedures represent a piece of code written in the PSQL language that allows SQL statement execution at the native speed of the engine and provides capabilities for a limited execution flow control.
The PSQL language is not general purpose language therefore its capabilities are limited when it comes to interaction with other systems.

Firebird stored procedures can be classified as follows:

* Procedures that do not return any results.
These are stored procedures that do not contain the `RETURNS` keyword in their header.
* Procedures that return only a single row of results.
These are stored procedures that contain the `RETURNS` keyword in their header, but do not contain the `SUSPEND` keyword in their procedure body.
These procedures can be viewed as functions that return multiple values.
These procedures are executed by using the `EXECUTE PROCEDURE` statement.
* Procedures that return a result set, also called "`selectable stored procedures`".
These are stored procedures that contain the `RETURNS` keyword in their header and the `SUSPEND` keyword in their procedure body, usually within a loop.
Selectable procedures are executed using the `"SELECT * FROM myProcedure(...)"` SQL statement.
It is also allowed to use the `EXECUTE PROCEDURE` statement, however that might produce strange results, since for selectable procedures it is equivalent to executing a `SELECT` statement, but doing only one fetch after the select.
If the procedure implementation relies on the fact that all rows that it returns must be fetched, the logic will be broken.

Consider the following stored procedure that returns factorial of the specified number.

[source,sql]
.Source code for the procedure that multiplies two integers
----
CREATE PROCEDURE factorial(
  max_value INTEGER
) RETURNS (
  factorial INTEGER
) AS
  DECLARE VARIABLE temp INTEGER;
  DECLARE VARIABLE counter INTEGER;
BEGIN
  counter = 0;
  temp = 1;
  WHILE (counter <= max_value) DO BEGIN
    IF (counter = 0) THEN
      temp = 1;
    ELSE
      temp = temp * counter;
    counter = counter + 1;
  END
  factorial = temp;
END
----

This procedure can be executed using the EXECUTE PROCEDURE call.
When it is done in isql, the output looks as follows.

.Output of the EXECUTE PROCEDURE call in isql
....
SQL> EXECUTE PROCEDURE factorial(5);

   FACTORIAL
============
         120
....

Now let's modify this procedure to return each intermediate result to the client.

[source,sql]
.Modified procedure that returns each intermediate result
----
CREATE PROCEDURE factorial_selectable(
  max_value INTEGER
) RETURNS (
  row_num INTEGER,
  factorial INTEGER
) AS
  DECLARE VARIABLE temp INTEGER;
  DECLARE VARIABLE counter INTEGER;
BEGIN
  counter = 0;
  temp = 1;
  WHILE (counter <= max_value) DO BEGIN
    IF (row_num = 0) THEN
      temp = 1;
    ELSE
      temp = temp * counter;
    factorial = temp;
    row_num = counter;
    counter = counter + 1;
    SUSPEND;
  END
END
----

If you create this procedure using the isql command line tool and then execute `SELECT * FROM factorial_selectable(5)`, the output
will be like this:

.Output of the modified procedure
....
SQL> SELECT * FROM factorial_selectable(5);

     ROW_NUM    FACTORIAL
============ ============
           0            1
           1            1
           2            2
           3            6
           4           24
           5          120
....

==== Using the CallableStatement

Let's see how the procedures defined above can be accessed from Java.

First, we can execute this procedure from the first example in the previous section using `EXECUTE PROCEDURE` and `PreparedStatement`, however this approach requires some more code for result set handling.

[source,java]
.Example of using the PreparedStatement to call executable procedure
----
try (PreparedStatement stmt = connection.prepareStatement(
         "EXECUTE PROCEDURE factorial(?)")) {

  stmt.setInt(1, 2);
    
  try (ResultSet rs = stmt.executeQuery()) {
    rs.next(); // move cursor to the first row
       
    int result = rs.getInt(1);
  }
}
----

However, the standard for calling stored procedures in JDBC is to use the `CallableStatement`.
The call can be specified using the escaped syntax, but native Firebird `EXECUTE PROCEDURE` syntax is also supported.

// TODO Revise examples, 
// registering out parameter is not the 'right' method when producing result set
// The example is too overloaded by using selectable but handling as executable

[source,java]
.Accessing the executable procedure via CallableStatement
----
try (CallableStatement stmt = connection.prepareCall(
         "{call factorial(?,?)}")) {
    
  stmt.setInt(1, 2);
  stmt.registerOutParameter(2, Types.INTEGER);
    
  stmt.execute();
    
  int result = stmt.getInt(2);
}
----

Please note the difference in the number of parameters used in the examples.
The first example contained only IN parameter on position 1 and the OUT parameter was returned in the `ResultSet` on the first position, so it was accessed via index 1.

The latter example additionally contains the OUT parameter in the call.
We have used the `CallableStatement.registerOutParameter` method to tell the driver that the second parameter in our call is an OUT parameter of type INTEGER.
Parameters that were not marked as OUT are considered by Jaybird as IN parameters.
Finally, the `EXECUTE PROCEDURE factorial(?)` SQL statement is prepared and executed.
After executing the procedure call we get the result from the appropriate getter method.

It is worth mentioning that the stored procedure call preparation happens in the `CallableStatement.execute` method, and not in the `prepareCall` method of the `Connection` object.
Reason for this deviation from the specification is that Firebird does not allow to prepare a procedure without specifying parameters and set them only after the statement is prepared.
It seems that this part of the JDBC specification is modelled after the Oracle RDBMS and a workaround for this issue had to be delivered.
Another side effect of this issue is, that it is allowed to intermix input and output parameters, for example in the "IN, OUT, IN, OUT, OUT, IN" order.
Not that it makes much sense to do this, but it might help in some cases when porting applications from another database server.

It is also allowed to use a procedure call parameter both as an input and output parameter.
It is recommended to use this only when porting applications from the database servers that allow INOUT parameter types, such as Oracle.

The actual stored procedure call using the `CallableStatement` is equivalent to the call using the prepared statement as shown in the first example.
There is no measurable performance differences when using the callable statement interface.

The JDBC specification allows another syntax for the stored procedure calls:

[source,java]
.Calling stored procedure using different syntax
----
try (CallableStatement stmt = connection.prepareCall(
         "{?= call factorial(?}")) {
    
  stmt.registerOutParameter(1, Types.INTEGER);
  stmt.setInt(2, 2);
    
  stmt.execute();
    
  int result = stmt.getInt(1);
}
----

Note, that input parameter now has index 2, and not 1 as in the previous example.
This syntax seems to be more intuitive, as it looks like a function call.
It is possible to use this syntax for stored procedures that return more than one parameter by combining code from the second and the last examples.

Firebird stored procedures can also return result sets.
This is achieved by using the SUSPEND keyword inside the procedure body.
This keyword returns the current values of the output parameters as a single row to the client.

The following example is more complex and shows a stored procedure that computes a set of factorial of the numbers up to the specified number of rows.

The SELECT SQL statement is the natural way of accessing the selectable procedures in Firebird.
You "`select`" from such procedures using the `Statement` or `PreparedStatement` objects.

// TODO Simplify example below

With minor issues it is also possible to access selectable stored procedures through the `CallableStatement` interface.
The escaped call must include all IN and OUT parameters.
After the call is prepared, parameters are set the same way.
However, the application must explicitly tell the driver that selectable procedure is used and access to the result set is desired.
This is done by calling a Jaybird-specific method as shown in the example below.
When this is not done, the application has access only to the first row of the result set. *TODO* Outdated?

The getter methods from the `CallableStatement` interface will provide you access only to the first row of the result set.
In order to get access to the complete result set you have to either call the `executeQuery` method or the `execute` method followed by `getResultSet` method.

[source,java]
.Example of using selectable stored procedure via escaped syntax
----
import java.sql.*;
import org.firebirdsql.jdbc.*;
...
try (CallableStatement stmt = connection.prepareCall(
         "{call factorial(?, ?, ?)}")) {
    
  FirebirdCallableStatement fbStmt = 
      (FirebirdCallableStatement)stmt;
  fbStmt.setSelectableProcedure(true);
    
  stmt.setInt(1, 5);
  stmt.registerOutParameter(2, Types.INTEGER); // first OUT
  stmt.registerOutParameter(3, Types.INTEGER); // second OUT
    
  try (ResultSet rs = stmt.executeQuery()) {
    
    while(rs.next()) {
      int firstCol = rs.getInt(1);             // first OUT
      int secondCol = rs.getInt(2);            // second OUT
      int anotherSecondCol = stmt.getInt(3);   // second OUT
    }
  }
}
----

Note that OUT parameter positions differ when they are accessed through the `ResultSet` interface (the `firstCol` and `secondCol` variables in our example).
They are numbered in the order of their appearance in the procedure call starting with 1.

When OUT parameter is accessed through the `CallableStatement` interface (the `anotherSecondCol` parameter in our example), the registered position should be used.
In this case the result set can be used for navigation only.

==== Describing Output and Input Parameters

The `PreparedStatement.getMetaData` method is used to obtain description of the columns that will be returned by the prepared SELECT statement.
The method returns an instance of `java.sql.ResultSetMetaData` interface that among other descriptions provides the following:

* column type, name of the type, its scale and precision if relevant;
* column name, its label and the display size;
* name of the table, to which this column belongs;
* information whether the column is read-only or writable, whether it contains signed numbers, whether it can contain NULL values, etc.

Additionally, the JDBC 3.0 specification introduced the interface `java.sql.ParameterMetaData` that provides similar information for the input parameters of both `PreparedStatement` and `CallableStatement` objects.

NOTE: Due to the implementation specifics of the escaped syntax support for callable statements, it is not allowed to call
`getParameterMetaData` before all OUT parameters are registered.
Otherwise, the driver will try to prepare a procedure with an incorrect number of parameters and the database server will generate an error.

=== Batch Updates

Batch updates are intended to group multiple update operations to be submitted to a database server to be processed at once.
Firebird 3.0 and earlier did not provide support for such functionality, so Jaybird 4 and earlier emulate it by issuing separate update commands.

[.since]_Jaybird 5_ Firebird 4.0 added support for server-side batch updates, which is implemented in Jaybird 5 for prepared statements, see <<stmt-batch-server-side>>.

==== Batch Updates with java.sql.Statement interface

The `Statement` interface defines three methods for batch updates: `addBatch`, `executeBatch` and `clearBatch`.
It is allowed to add arbitrary INSERT/UPDATE/DELETE or DDL statement to the batch group.
Adding a statement that returns result set is an error.

[source,java]
.Example of batch updates using Statement object
----
try (Statement stmt = connection.createStatement()) {

  stmt.addBatch("UPDATE products " + 
      "SET amount = amount - 1 WHERE id = 1");
  stmt.addBatch("INSERT INTO orders(id, amount) VALUES(1, 1)");
    
  int[] updateCounts = stmt.executeBatch();
}
----

The JDBC specification recommends to turn the auto-commit mode off to guarantee standard behavior for all databases.
The specification explicitly states that behavior in auto-commit case is implementation defined.

In auto-commit mode, Jaybird executes a batch in a single transaction, i.e. the "all-or-nothing" principle.
A new transaction is started before the batch execution and is committed if there were no exceptions during batch execution, or is rolled back if at least one batch command generated an error.

The `Statement.executeBatch` method submits the job to the database server.
In case of successful execution of the complete batch, it returns an array of integers containing update counts for each of the commands.
Possible values are:

* 0 or positive value -- an update count for the corresponding update/DDL statement.
* `Statement.SUCCESS_NO_INFO` -- driver does not have any information about the update count, but it knows that statement was executed successfully.

The `Statement.executeBatch` method closes the current result set if one is open.
After successful execution the batch is cleared.
Calling `execute`, `executeUpdate` and `executeQuery` before the batch is executed does not have any effect on the currently added batch statements.

If at least one statement from the batch fails, a `java.sql.BatchUpdateException` is thrown.
Jaybird will stop executing statements from batch after the first error.
In auto-commit mode it will also roll back the transaction.
An application can obtain update counts for the already executed statements using `getUpdateCounts` method of the `BatchUpdateException` class.
The returned array will always contain fewer entries than there were statements in the batch, as it will only report the update counts of successfully executed statements.

==== Batch Updates with java.sql.PreparedStatement and java.sql.CallableStatement

Using batch updates with a prepared statement is conceptually similar to the `java.sql.Statement` approach.
The main difference is that only one statement can be used, but with different sets of parameter values.

[source,java]
.Example of batch updates with PreparedStatement
----
try (PreparedStatement stmt = connection.prepareStatement(
         "INSERT INTO products(id, name) VALUES(?, ?)")) {
    
  stmt.setInt(1, 1);
  stmt.setString(2, "apple");
  stmt.addBatch();
    
  stmt.setInt(1, 2);
  stmt.setString(2, "orange");
  stmt.addBatch();
    
  int[] updateCounts = stmt.executeBatch();
}
----

[source,java]
.Example of batch updates with CallableStatement
----
try (CallableStatement stmt = connection.prepareCall(
         "{call add_product(?, ?)")) {
    
  stmt.setInt(1, 1);
  stmt.setString(2, "apple");
  stmt.addBatch();
    
  stmt.setInt(1, 2);
  stmt.setString(2, "orange");
  stmt.addBatch();
    
  int[] updateCounts = stmt.executeBatch();
}
----

[[stmt-batch-server-side]]
==== Server-side Batch Updates

[.since]_Jaybird 5_ +
[.since]_Firebird 4.0_

Jaybird 5 adds support for server-side batch updates when connecting to Firebird 4.0 or higher.
This support comes with a number of limitations:

* Only supported on the pure Java protocol, not on native or embedded.
* Only supported on `PreparedStatement`.
** The `Statement` batch behaviour is not supported by server-side batch updates.
** The `CallableStatement` implementation is more complex than prepared statement, so the decision was made not to reimplement this using server-side batch updates.
The implementation might be rewritten in a future Jaybird version, if there is sufficient demand.
As a workaround, use `execute procedure` or `++{call procedure_name(...)}++` from a `PreparedStatement`.
* Requesting generated-keys will fall back to emulated behaviour as server-side batches do not support returning values produced by the `RETURNING` clause.
* Firebird 4.0 has additional facilities to send `BLOB` values as part of the batch update, but this is not yet used by Jaybird.

When server-side batch support is unavailable, either because the server doesn't support it, or because of above limitations, or if the <<ref-batch-use-server-batch,connection property `useServerBatch`>> is `false`, Jaybird will fall back to the emulated behaviour.

By default, Jaybird will request the maximum server-side batch buffer size (256MB as of Firebird 4.0).
A smaller buffer can be requested with <<ref-batch-server-batch-buffer-size,connection property `serverBatchBufferSize`>> (value in bytes).
Jaybird does not track the consumption of the server-side batch buffer.
Attempting to execute a batch larger than this buffer will fail with error "`Internal buffer overflow - batch too big`" (`isc_batch_too_big`, `335545198`).
The 256MB buffer used with Jaybird defaults on Firebird 4.0 is sufficient to accommodate several thousand rows at maximum row size (a naive calculation says around 4000 rows, but this doesn't account for all overhead of a row).

=== Escape Syntax

The escape syntax was introduced as a portable JDBC-specific syntax to represent parts of the SQL language that are (or were) usually implemented differently by database vendors.
The escaped syntax is also used to define features that might not be implemented by the database server, but can have an appropriate implementation in the driver.

The JDBC specification defines escaped syntax for the following

* scalar functions
* date and time literals
* outer joins
* calling stored procedures
* escape characters for LIKE clauses

==== Scalar Functions

Escaped syntax for the scalar function call is defined as

....
{fn <function-name> (argument list)}
....

For example, `{fn concat('Firebird', 'Java')}` results in the code `('Firebird'||'Java')` in the actual statement sent to the server.
"<<jdbcescape>>" provides a list of supported scalar functions.

==== Date and Time Literals

It is possible to include date and time literals in SQL statements.
In order to guarantee that each database will interpret the literal identically, the JDBC specification provides following syntax to specify them:

Date literal escaped syntax:

....
{d 'yyyy-mm-dd'}
....

Time literal escaped syntax:

....
{t 'hh:mm:ss'}
....

Timestamp literal syntax (fractional seconds part `'.f...'` can be
omitted):

....
{ts 'yyyy-mm-dd hh:mm:ss.f...'}
....

==== Outer Joins

Due to the various approaches to specify outer joins (for instance, the Oracle "(+)" syntax), the JDBC specification provides the following syntax:

....
{oj <outer join>}
....

where the outer join is specified as

....
<outer join> ::=
    <table name> {LEFT|RIGHT|FULL} OUTER JOIN
    {<table name> | <outer join>} ON >search condition>
....

An example SQL statement would look like this:

....
SELECT * FROM {oj tableA a
    LEFT OUTER JOIN tableB b ON a.id = b.id}
....

==== Stored Procedures

The escaped syntax for stored procedures is described in details in section <<callable-statement>>.

==== LIKE Escaped Characters

The percent sign ('```%```') and underscore ('```_```') characters are wild cards in the LIKE predicate of SQL.
In order to interpret them literally they must be preceded by the backslash character ('```\```') that is called the escape character.
The escaped syntax for this case identifies which character is used as an escape character:

....
{escape '<escape character>'}
....

